package com.security.vulnscanner.service;

import com.security.vulnscanner.model.Vulnerability;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;

@Slf4j
@Component
public class VulnerabilityValidator {
    
    private final HttpClient httpClient = HttpClient.newBuilder()
        .connectTimeout(Duration.ofSeconds(30))
        .build();
    
    /**
     * Validates SQL Injection vulnerability with multiple techniques
     */
    public ValidationResult validateSQLi(String url, String payload, String userAgent) {
        ValidationResult result = new ValidationResult();
        result.setVulnerabilityType("SQL Injection");
        int confidence = 0;
        List<String> evidence = new ArrayList<>();
        
        try {
            // Step 1: Baseline request
            Response baseline = sendRequest(url, "normal_input", userAgent);
            
            // Step 2: Error-based detection
            Response errorTest = sendRequest(url, "' OR '1'='1", userAgent);
            if (containsSQLError(errorTest.getBody())) {
                confidence += 40;
                evidence.add("SQL error messages detected in response");
            }
            
            // Step 3: Time-based blind SQLi
            long startTime = System.currentTimeMillis();
            Response timeTest = sendRequest(url, "' AND SLEEP(5)--", userAgent);
            long responseTime = System.currentTimeMillis() - startTime;
            
            if (responseTime > 5000) {
                confidence += 35;
                evidence.add(String.format("Time-based SQLi confirmed (%.2fs delay)", responseTime / 1000.0));
            }
            
            // Step 4: Boolean-based blind SQLi
            Response booleanTrue = sendRequest(url, "' AND '1'='1", userAgent);
            Response booleanFalse = sendRequest(url, "' AND '1'='2", userAgent);
            
            if (!booleanTrue.getBody().equals(booleanFalse.getBody()) &&
                booleanTrue.getBody().equals(baseline.getBody())) {
                confidence += 25;
                evidence.add("Boolean-based SQLi: Different responses for true/false conditions");
            }
            
            result.setConfirmed(confidence >= 70);
            result.setConfidence(Math.min(confidence, 100));
            result.setEvidence(evidence);
            
        } catch (Exception e) {
            log.error("Error validating SQL injection: {}", e.getMessage());
            result.setConfirmed(false);
            result.setConfidence(0);
        }
        
        return result;
    }
    
    /**
     * Validates XSS vulnerability with multiple payloads and contexts
     */
    public ValidationResult validateXSS(String url, String payload, String userAgent) {
        ValidationResult result = new ValidationResult();
        result.setVulnerabilityType("Cross-Site Scripting");
        int confidence = 0;
        List<String> evidence = new ArrayList<>();
        
        try {
            String[] testPayloads = {
                "<script>alert(1)</script>",
                "<img src=x onerror=alert(1)>",
                "<svg onload=alert(1)>",
                "javascript:alert(1)",
                "\"><script>alert(1)</script>"
            };
            
            int successfulPayloads = 0;
            for (String testPayload : testPayloads) {
                Response response = sendRequest(url, testPayload, userAgent);
                
                if (isPayloadReflected(response.getBody(), testPayload)) {
                    successfulPayloads++;
                    
                    // Check if it's actually executable (not encoded)
                    if (response.getBody().contains(testPayload)) {
                        confidence += 20;
                        evidence.add("Payload reflected without encoding: " + testPayload.substring(0, 30));
                    } else if (isPartiallyEncoded(response.getBody(), testPayload)) {
                        confidence += 10;
                        evidence.add("Payload partially encoded (might still be exploitable)");
                    }
                }
            }
            
            if (successfulPayloads >= 3) {
                confidence += 30;
                evidence.add(String.format("Multiple payloads successful (%d/%d)", 
                    successfulPayloads, testPayloads.length));
            }
            
            result.setConfirmed(confidence >= 60);
            result.setConfidence(Math.min(confidence, 100));
            result.setEvidence(evidence);
            
        } catch (Exception e) {
            log.error("Error validating XSS: {}", e.getMessage());
            result.setConfirmed(false);
            result.setConfidence(0);
        }
        
        return result;
    }
    
    /**
     * Validates authentication bypass
     */
    public ValidationResult validateAuthBypass(String protectedUrl, String userAgent) {
        ValidationResult result = new ValidationResult();
        result.setVulnerabilityType("Authentication Bypass");
        int confidence = 0;
        List<String> evidence = new ArrayList<>();
        
        try {
            // Try accessing without credentials
            Response noAuthResponse = sendRequest(protectedUrl, null, userAgent);
            
            if (noAuthResponse.getStatusCode() == 200 || noAuthResponse.getStatusCode() == 201) {
                confidence = 95;
                evidence.add("Protected endpoint accessible without authentication");
                evidence.add("HTTP " + noAuthResponse.getStatusCode() + " returned");
            } else if (noAuthResponse.getStatusCode() != 401 && noAuthResponse.getStatusCode() != 403) {
                confidence = 40;
                evidence.add("Unexpected status code: " + noAuthResponse.getStatusCode());
            }
            
            result.setConfirmed(confidence >= 70);
            result.setConfidence(confidence);
            result.setEvidence(evidence);
            
        } catch (Exception e) {
            log.error("Error validating auth bypass: {}", e.getMessage());
            result.setConfirmed(false);
        }
        
        return result;
    }
    
    private Response sendRequest(String url, String paramValue, String userAgent) throws Exception {
        String testUrl = url;
        if (paramValue != null) {
            testUrl = url.contains("?") ? 
                url + "&test=" + java.net.URLEncoder.encode(paramValue, "UTF-8") :
                url + "?test=" + java.net.URLEncoder.encode(paramValue, "UTF-8");
        }
        
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(testUrl))
            .header("User-Agent", userAgent)
            .timeout(Duration.ofSeconds(10))
            .GET()
            .build();
        
        HttpResponse<String> httpResponse = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
        
        return new Response(httpResponse.statusCode(), httpResponse.body());
    }
    
    private boolean containsSQLError(String body) {
        String[] errorPatterns = {
            "SQL syntax",
            "mysql_fetch",
            "ORA-",
            "PostgreSQL",
            "SQLite",
            "Microsoft SQL",
            "ODBC",
            "SQLException",
            "mysql_num_rows",
            "pg_query",
            "sqlite3_",
            "Unclosed quotation mark"
        };
        
        String lowerBody = body.toLowerCase();
        for (String pattern : errorPatterns) {
            if (lowerBody.contains(pattern.toLowerCase())) {
                return true;
            }
        }
        return false;
    }
    
    private boolean isPayloadReflected(String body, String payload) {
        String lowerBody = body.toLowerCase();
        String lowerPayload = payload.toLowerCase();
        
        return lowerBody.contains(lowerPayload) || 
               lowerBody.contains(payload) ||
               body.contains(payload);
    }
    
    private boolean isPartiallyEncoded(String body, String payload) {
        // Check for HTML entity encoding
        String encoded = payload.replace("<", "&lt;").replace(">", "&gt;");
        return body.contains(encoded);
    }
    
    @Data
    public static class ValidationResult {
        private String vulnerabilityType;
        private boolean confirmed;
        private int confidence;
        private List<String> evidence = new ArrayList<>();
        private String recommendation;
    }
    
    @Data
    @AllArgsConstructor
    private static class Response {
        private int statusCode;
        private String body;
    }
}
